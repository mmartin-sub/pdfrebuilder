#!/usr/bin/env python3
"""
Debug test to investigate why test_enhanced_security.py is being killed.
This test includes verbose logging and step-by-step execution to identify the exact cause.
"""

import logging
import os
import signal
import sys
import tempfile
import time
from pathlib import Path

import psutil

# Set up verbose logging
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler("debug_security_test.log"),
    ],
)

logger = logging.getLogger(__name__)


def signal_handler(signum, frame):
    """Handle signals to understand why the process is being killed."""
    logger.critical(f"SIGNAL RECEIVED: {signum} ({signal.Signals(signum).name})")
    logger.critical(f"Frame: {frame}")
    logger.critical(f"Current memory usage: {psutil.Process().memory_info().rss / 1024 / 1024:.2f} MB")
    logger.critical(f"Current CPU usage: {psutil.Process().cpu_percent():.2f}%")
    sys.exit(1)


# Register signal handlers (SIGKILL cannot be caught)
signal.signal(signal.SIGTERM, signal_handler)
if hasattr(signal, "SIGXCPU"):
    signal.signal(signal.SIGXCPU, signal_handler)  # CPU time limit exceeded
if hasattr(signal, "SIGXFSZ"):
    signal.signal(signal.SIGXFSZ, signal_handler)  # File size limit exceeded


class DebugSecurityTest:
    """Debug version of security tests with extensive logging."""

    def setup_method(self):
        """Setup with detailed system information."""
        logger.info("=== TEST SETUP START ===")

        # Log system information
        logger.info(f"Python version: {sys.version}")
        logger.info(f"Platform: {sys.platform}")
        logger.info(f"PID: {os.getpid()}")
        logger.info(f"UID: {os.getuid()}")
        logger.info(f"GID: {os.getgid()}")

        # Log system resources
        memory = psutil.virtual_memory()
        logger.info(f"Total memory: {memory.total / 1024 / 1024:.2f} MB")
        logger.info(f"Available memory: {memory.available / 1024 / 1024:.2f} MB")
        logger.info(f"Memory usage: {memory.percent:.2f}%")

        cpu_count = psutil.cpu_count()
        logger.info(f"CPU count: {cpu_count}")
        logger.info(f"CPU usage: {psutil.cpu_percent():.2f}%")

        # Log resource limits
        try:
            import resource

            logger.info(f"Memory limit (RLIMIT_AS): {resource.getrlimit(resource.RLIMIT_AS)}")
            logger.info(f"CPU time limit (RLIMIT_CPU): {resource.getrlimit(resource.RLIMIT_CPU)}")
            logger.info(f"File size limit (RLIMIT_FSIZE): {resource.getrlimit(resource.RLIMIT_FSIZE)}")
            logger.info(f"Process limit (RLIMIT_NPROC): {resource.getrlimit(resource.RLIMIT_NPROC)}")
        except Exception as e:
            logger.warning(f"Could not get resource limits: {e}")

        # Check for containerization
        if os.path.exists("/.dockerenv"):
            logger.info("Running in Docker container")

        if os.path.exists("/proc/1/cgroup"):
            try:
                with open("/proc/1/cgroup") as f:
                    cgroup_info = f.read()
                    if "docker" in cgroup_info or "containerd" in cgroup_info:
                        logger.info("Running in containerized environment")
                        logger.debug(f"Cgroup info: {cgroup_info[:200]}...")
            except Exception as e:
                logger.debug(f"Could not read cgroup info: {e}")

        logger.info("=== TEST SETUP COMPLETE ===")

    def test_basic_imports(self):
        """Test basic imports to ensure modules are available."""
        logger.info("=== TESTING BASIC IMPORTS ===")

        try:
            logger.info("Importing subprocess_utils...")
            logger.info("✓ subprocess_utils imported successfully")

            logger.info("Importing SecurityError...")
            logger.info("✓ SecurityError imported successfully")

            logger.info("Importing other security components...")
            logger.info("✓ All security components imported successfully")

        except Exception as e:
            logger.error(f"Import failed: {e}")
            raise

    def test_simple_runner_creation(self):
        """Test creating a SecureSubprocessRunner without resource limits."""
        logger.info("=== TESTING SIMPLE RUNNER CREATION ===")

        try:
            from src.security.subprocess_utils import SecureSubprocessRunner

            logger.info("Creating SecureSubprocessRunner with minimal settings...")
            runner = SecureSubprocessRunner(
                timeout=10,
                max_memory_mb=1024,  # Generous limit
                enable_sandboxing=False,  # Disable sandboxing initially
            )
            logger.info("✓ SecureSubprocessRunner created successfully")

            # Log runner configuration
            logger.info(f"Runner timeout: {runner.timeout}")
            logger.info(f"Runner base_path: {runner.base_path}")
            logger.info(f"Runner sandboxing enabled: {runner.enable_sandboxing}")

        except Exception as e:
            logger.error(f"Runner creation failed: {e}")
            raise

    def test_simple_command_execution(self):
        """Test executing a simple, safe command."""
        logger.info("=== TESTING SIMPLE COMMAND EXECUTION ===")

        try:
            from src.security.subprocess_utils import SecureSubprocessRunner

            logger.info("Creating runner for command execution...")
            runner = SecureSubprocessRunner(timeout=30, max_memory_mb=1024, enable_sandboxing=False)

            logger.info("Executing simple command: python --version")
            start_time = time.time()

            # Monitor memory before execution
            process = psutil.Process()
            memory_before = process.memory_info().rss / 1024 / 1024
            logger.info(f"Memory before execution: {memory_before:.2f} MB")

            result = runner.run(["python", "--version"])

            execution_time = time.time() - start_time
            memory_after = process.memory_info().rss / 1024 / 1024

            logger.info(f"Command completed in {execution_time:.2f} seconds")
            logger.info(f"Return code: {result.returncode}")
            logger.info(f"Memory after execution: {memory_after:.2f} MB")
            logger.info(f"Memory delta: {memory_after - memory_before:.2f} MB")

            if result.stdout:
                logger.info(f"Stdout: {result.stdout.strip()}")
            if result.stderr:
                logger.info(f"Stderr: {result.stderr.strip()}")

            assert result.returncode == 0
            logger.info("✓ Simple command execution successful")

        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            raise

    def test_resource_monitoring_step_by_step(self):
        """Test resource monitoring with detailed step-by-step logging."""
        logger.info("=== TESTING RESOURCE MONITORING STEP BY STEP ===")

        try:
            from src.security.subprocess_utils import SecureSubprocessRunner

            logger.info("Step 1: Creating runner with resource monitoring...")
            runner = SecureSubprocessRunner(
                max_memory_mb=512,  # Moderate limit
                timeout=20,
                enable_sandboxing=False,  # Start without sandboxing
            )

            logger.info("Step 2: Checking initial system state...")
            process = psutil.Process()
            initial_memory = process.memory_info().rss / 1024 / 1024
            initial_cpu = process.cpu_percent()
            logger.info(f"Initial memory: {initial_memory:.2f} MB")
            logger.info(f"Initial CPU: {initial_cpu:.2f}%")

            logger.info("Step 3: Executing command with monitoring...")
            start_time = time.time()

            # Execute a slightly longer-running command (safe version)
            result = runner.run(
                [
                    "python",
                    "-c",
                    "import time; print('Starting'); time.sleep(0.5); print('Done')",
                ],
                allow_custom_executables=True,
            )

            execution_time = time.time() - start_time
            final_memory = process.memory_info().rss / 1024 / 1024
            final_cpu = process.cpu_percent()

            logger.info(f"Step 4: Command completed in {execution_time:.2f} seconds")
            logger.info(f"Final memory: {final_memory:.2f} MB")
            logger.info(f"Final CPU: {final_cpu:.2f}%")
            logger.info(f"Memory delta: {final_memory - initial_memory:.2f} MB")

            logger.info("Step 5: Checking runner statistics...")
            stats = runner.get_execution_stats()
            logger.info(f"Execution stats: {stats}")

            assert result.returncode == 0
            logger.info("✓ Resource monitoring test successful")

        except Exception as e:
            logger.error(f"Resource monitoring test failed: {e}")
            logger.error(f"Current memory: {psutil.Process().memory_info().rss / 1024 / 1024:.2f} MB")
            raise

    def test_problematic_operations_individually(self):
        """Test potentially problematic operations one by one."""
        logger.info("=== TESTING PROBLEMATIC OPERATIONS INDIVIDUALLY ===")

        operations = [
            ("psutil.Process creation", lambda: psutil.Process()),
            ("Memory info access", lambda: psutil.Process().memory_info()),
            ("CPU percent access", lambda: psutil.Process().cpu_percent()),
            ("Resource limit import", lambda: __import__("resource")),
        ]

        for name, operation in operations:
            try:
                logger.info(f"Testing: {name}")
                start_time = time.time()
                result = operation()
                duration = time.time() - start_time
                logger.info(f"✓ {name} successful in {duration:.4f}s: {type(result)}")
            except Exception as e:
                logger.error(f"✗ {name} failed: {e}")
                # Continue with other operations

    def test_resource_limits_safely(self):
        """Test resource limit setting with safety checks."""
        logger.info("=== TESTING RESOURCE LIMITS SAFELY ===")

        try:
            import resource

            logger.info("Current resource limits:")
            limits_to_check = [
                (resource.RLIMIT_AS, "RLIMIT_AS (memory)"),
                (resource.RLIMIT_CPU, "RLIMIT_CPU (CPU time)"),
                (resource.RLIMIT_FSIZE, "RLIMIT_FSIZE (file size)"),
            ]

            for limit_type, name in limits_to_check:
                try:
                    soft, hard = resource.getrlimit(limit_type)
                    logger.info(f"  {name}: soft={soft}, hard={hard}")
                except Exception as e:
                    logger.warning(f"  {name}: Could not get limit - {e}")

            logger.info("Testing safe resource limit setting...")

            # Try to set a very generous memory limit
            try:
                current_memory = psutil.virtual_memory().available
                safe_limit = min(current_memory // 2, 2 * 1024 * 1024 * 1024)  # 2GB or half available
                logger.info(f"Attempting to set memory limit to {safe_limit // 1024 // 1024} MB")

                # Get current limit first
                current_soft, current_hard = resource.getrlimit(resource.RLIMIT_AS)
                logger.info(f"Current memory limit: soft={current_soft}, hard={current_hard}")

                # Only set if we're not making it more restrictive
                if current_soft == resource.RLIM_INFINITY or safe_limit < current_soft:
                    resource.setrlimit(resource.RLIMIT_AS, (safe_limit, current_hard))
                    logger.info("✓ Memory limit set successfully")
                else:
                    logger.info("✓ Memory limit already appropriate, not changing")

            except Exception as e:
                logger.warning(f"Could not set memory limit: {e}")

        except ImportError:
            logger.warning("Resource module not available")
        except Exception as e:
            logger.error(f"Resource limit testing failed: {e}")

    def test_audit_logging_safely(self):
        """Test audit logging with temporary files."""
        logger.info("=== TESTING AUDIT LOGGING SAFELY ===")

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                audit_file = Path(temp_dir) / "debug_audit.log"
                logger.info(f"Using temporary audit file: {audit_file}")

                from src.security.subprocess_utils import SecureSubprocessRunner

                runner = SecureSubprocessRunner(
                    audit_log_file=audit_file,
                    enable_sandboxing=False,
                    max_memory_mb=1024,
                )

                logger.info("Executing command with audit logging...")
                result = runner.run(["python", "--version"])

                logger.info("Checking audit log...")
                if audit_file.exists():
                    audit_content = audit_file.read_text()
                    logger.info(f"Audit log size: {len(audit_content)} bytes")
                    logger.info(f"Audit log preview: {audit_content[:200]}...")
                    logger.info("✓ Audit logging successful")
                else:
                    logger.warning("Audit log file was not created")

        except Exception as e:
            logger.error(f"Audit logging test failed: {e}")
            raise


def test_debug_security_kill_investigation():
    """Main debug test function."""
    logger.info("=== STARTING SECURITY TEST KILL INVESTIGATION ===")

    debug_test = DebugSecurityTest()

    try:
        debug_test.setup_method()
        debug_test.test_basic_imports()
        debug_test.test_simple_runner_creation()
        debug_test.test_simple_command_execution()
        debug_test.test_problematic_operations_individually()
        debug_test.test_resource_limits_safely()
        debug_test.test_resource_monitoring_step_by_step()
        debug_test.test_audit_logging_safely()

        logger.info("=== ALL DEBUG TESTS COMPLETED SUCCESSFULLY ===")

    except Exception as e:
        logger.error(f"=== DEBUG TEST FAILED: {e} ===")
        logger.error(f"Final memory usage: {psutil.Process().memory_info().rss / 1024 / 1024:.2f} MB")
        raise


if __name__ == "__main__":
    test_debug_security_kill_investigation()
