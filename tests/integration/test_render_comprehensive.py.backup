"""
Comprehensive tests for the render module functionality.

This module tests the render.py functionality including:
- JSON serialization for various types
- Text rendering with fallback mechanisms
- Vector element rendering
- Element rendering with different types
- Color conversion and handling
- Font registration integration
"""

import unittest
from unittest.mock import Mock, patch

import fitz

from src.render import _render_element, _render_text_with_fallback, _render_vector_element, json_serializer


class TestJSONSerializer(unittest.TestCase):
    """Test cases for JSON serialization functionality"""

    def test_bytes_serialization(self):
        """Test serialization of bytes objects"""
        test_bytes = b"Hello World"
        result = json_serializer(test_bytes)
        self.assertEqual(result, "Hello World")

    def test_bytes_with_invalid_utf8(self):
        """Test serialization of bytes with invalid UTF-8"""
        test_bytes = b"\xff\xfe\x00\x00"
        result = json_serializer(test_bytes)
        # Should not raise exception, should handle gracefully
        self.assertIsInstance(result, str)

    def test_fitz_rect_serialization(self):
        """Test serialization of fitz.Rect objects"""
        rect = fitz.Rect(10, 20, 100, 200)
        result = json_serializer(rect)
        self.assertEqual(result, [10.0, 20.0, 100.0, 200.0])

    def test_fitz_point_serialization(self):
        """Test serialization of fitz.Point objects"""
        point = fitz.Point(50, 75)
        result = json_serializer(point)
        self.assertEqual(result, [50.0, 75.0])

    def test_fitz_matrix_serialization(self):
        """Test serialization of fitz.Matrix objects"""
        matrix = fitz.Matrix(1.0, 0.0, 0.0, 1.0, 10.0, 20.0)
        result = json_serializer(matrix)
        self.assertEqual(len(result), 6)  # Matrix has 6 components

    def test_float_special_values_serialization(self):
        """Test serialization of special float values (NaN, infinity)"""
        test_cases = [
            (float("nan"), "nan"),
            (float("inf"), "inf"),
            (float("-inf"), "-inf"),
        ]

        for value, expected in test_cases:
            with self.subTest(value=value):
                result = json_serializer(value)
                self.assertEqual(result, expected)

    def test_float_negative_inf_serialization(self):
        """Test serialization of negative infinity"""
        result = json_serializer(float("-inf"))
        self.assertEqual(result, "-inf")

    def test_normal_float_serialization(self):
        """Test serialization of normal float values"""
        result = json_serializer(3.14159)
        self.assertEqual(result, 3.14159)

    def test_unsupported_type_raises_error(self):
        """Test that unsupported types raise TypeError"""
        with self.assertRaises(TypeError) as context:
            json_serializer(object())

        # Log exception in debug mode as required
        import logging

        logger = logging.getLogger(__name__)
        logger.debug(f"Expected TypeError for unsupported type: {context.exception}")

        self.assertIn("is not JSON serializable", str(context.exception))


class TestRenderTextWithFallback(unittest.TestCase):
    """Test cases for text rendering with fallback functionality"""

    def setUp(self):
        """Set up test fixtures"""
        self.mock_page = Mock()
        self.rect = fitz.Rect(100, 100, 300, 150)
        self.text = "Test Text"
        self.font = "Arial"
        self.size = 12
        self.color = (0, 0, 0)

    def test_render_text_with_textbox(self):
        """Test text rendering using textbox method"""
        self.mock_page.insert_textbox.return_value = 1  # Success

        result = _render_text_with_fallback(
            self.mock_page,
            self.rect,
            self.text,
            self.font,
            self.size,
            self.color,
            use_textbox=True,
        )

        self.assertIsInstance(result, dict)
        self.assertEqual(result["fontname"], self.font)
        self.assertEqual(result["fontsize"], self.size)
        self.mock_page.insert_textbox.assert_called_once()

    def test_render_text_with_textbox_fallback(self):
        """Test text rendering with textbox fallback behavior"""
        self.mock_page.insert_textbox.return_value = -1  # Failure (negative means failure)

        result = _render_text_with_fallback(
            self.mock_page,
            self.rect,
            self.text,
            self.font,
            self.size,
            self.color,
            use_textbox=True,
        )

        self.assertIsInstance(result, dict)
        self.assertEqual(result["fontname"], self.font)
        # Should have attempted textbox twice (original + second pass)
        self.assertEqual(self.mock_page.insert_textbox.call_count, 2)

    def test_render_text_with_htmlbox(self):
        """Test text rendering using htmlbox method"""
        self.mock_page.insert_htmlbox.return_value = 1  # Success

        result = _render_text_with_fallback(
            self.mock_page,
            self.rect,
            self.text,
            self.font,
            self.size,
            self.color,
            use_htmlbox=True,
        )

        self.assertIsInstance(result, dict)
        self.assertIn("htmlbox_rect", result)
        self.assertIn("htmlbox_rc", result)
        self.mock_page.insert_htmlbox.assert_called_once()

    def test_render_text_direct_insert(self):
        """Test direct text insertion without textbox"""
        result = _render_text_with_fallback(
            self.mock_page,
            self.rect,
            self.text,
            self.font,
            self.size,
            self.color,
            use_textbox=False,
        )

        self.assertIsInstance(result, dict)
        self.assertIn("text_content", result)
        self.assertIn("point", result)
        self.mock_page.insert_text.assert_called_once()

    def test_render_text_exception_handling(self):
        """Test exception handling during text rendering"""
        self.mock_page.insert_text.side_effect = RuntimeError("Rendering failed")

        # The function doesn't handle exceptions internally, so it should propagate
        with self.assertRaises(RuntimeError) as context:
            _render_text_with_fallback(self.mock_page, self.rect, self.text, self.font, self.size, self.color)

        # Log exception in debug mode as required
        import logging

        logger = logging.getLogger(__name__)
        logger.debug(f"Expected exception caught during test: {context.exception}")


class TestRenderVectorElement(unittest.TestCase):
    """Test cases for vector element rendering"""

    def setUp(self):
        """Set up test fixtures"""
        self.mock_page = Mock()
        self.mock_shape = Mock()
        self.mock_page.new_shape.return_value = self.mock_shape

    @patch("src.render._convert_color_to_rgb")
    def test_render_simple_drawing_commands(self, mock_convert_color):
        """Test rendering of simple drawing commands"""
        mock_convert_color.side_effect = lambda x: (1.0, 0.0, 0.0) if x else None

        element_data = {
            "type": "drawing",
            "bbox": [100, 100, 200, 200],
            "color": [255, 0, 0],
            "fill": [0, 255, 0],
            "width": 2.0,
            "drawing_commands": [
                {"cmd": "M", "pts": [100, 100]},
                {"cmd": "L", "pts": [200, 200]},
                {"cmd": "H"},
            ],
        }

        result = _render_vector_element(self.mock_page, element_data)

        self.mock_page.new_shape.assert_called_once()
        self.mock_shape.draw_polyline.assert_called()
        self.mock_shape.finish.assert_called_once()
        self.assertIsInstance(result, dict)

    @patch("src.render._convert_color_to_rgb")
    def test_render_curve_commands(self, mock_convert_color):
        """Test rendering of curve drawing commands"""
        mock_convert_color.side_effect = lambda x: (0.0, 0.0, 1.0) if x else None

        element_data = {
            "type": "drawing",
            "bbox": [100, 100, 300, 300],
            "color": [0, 0, 255],
            "drawing_commands": [
                {"cmd": "M", "pts": [100, 100]},
                {
                    "cmd": "C",
                    "pts": [100, 100, 150, 150, 200, 200, 300, 300],
                },  # 8 coordinates format
                {"cmd": "H"},
            ],
        }

        _render_vector_element(self.mock_page, element_data)

        self.mock_shape.draw_bezier.assert_called()

    @patch("src.render._convert_color_to_rgb")
    def test_render_rectangle_primitive(self, mock_convert_color):
        """Test rendering of rectangle primitive"""
        mock_convert_color.return_value = (1.0, 1.0, 0.0)

        element_data = {
            "type": "drawing",
            "bbox": [100, 100, 200, 200],
            "fill": [255, 255, 0],
            "drawing_commands": [{"cmd": "rect", "bbox": [100, 100, 200, 200]}],
        }

        _render_vector_element(self.mock_page, element_data)

        self.mock_shape.draw_rect.assert_called()

    @patch("src.render._convert_color_to_rgb")
    def test_render_ellipse_primitive(self, mock_convert_color):
        """Test rendering of ellipse primitive"""
        mock_convert_color.return_value = (0.5, 0.5, 0.5)

        element_data = {
            "type": "drawing",
            "bbox": [100, 100, 200, 200],
            "fill": [128, 128, 128],
            "drawing_commands": [{"cmd": "ellipse", "bbox": [100, 100, 200, 200]}],
        }

        _render_vector_element(self.mock_page, element_data)

        self.mock_shape.draw_oval.assert_called()

    def test_render_vector_with_no_commands(self):
        """Test rendering vector element with no drawing commands"""
        element_data = {
            "type": "drawing",
            "bbox": [100, 100, 200, 200],
            "drawing_commands": [],
        }

        result = _render_vector_element(self.mock_page, element_data)

        # Should return error and not create shape
        self.assertIn("error", result)
        self.mock_page.new_shape.assert_not_called()

    def test_render_vector_exception_handling(self):
        """Test exception handling in vector rendering"""
        self.mock_page.new_shape.side_effect = RuntimeError("Shape creation failed")

        element_data = {
            "type": "drawing",
            "bbox": [100, 100, 200, 200],
            "drawing_commands": [{"cmd": "M", "pts": [100, 100]}],
        }

        # Should not raise exception, should handle gracefully
        result = _render_vector_element(self.mock_page, element_data)

        # Log exception in debug mode as required
        import logging

        logger = logging.getLogger(__name__)
        logger.debug(f"Vector rendering handled exception gracefully: {result.get('error', 'No error info')}")

        # Verify the function handled the exception gracefully
        self.assertIn("error", result)


class TestRenderElement(unittest.TestCase):
    """Test cases for general element rendering"""

    def setUp(self):
        """Set up test fixtures"""
        self.mock_page = Mock()
        self.page_idx = 0
        self.page_overrides = {}
        self.config = {}

    @patch("src.render._render_text_with_fallback")
    @patch("src.render.ensure_font_registered")
    def test_render_text_element(self, mock_ensure_font, mock_render_text):
        """Test rendering of text elements"""
        mock_ensure_font.return_value = "Arial"
        mock_render_text.return_value = {"fontname": "Arial", "fontsize": 12}

        element = {
            "type": "text",
            "text": "Hello World",
            "bbox": [100, 100, 300, 150],
            "font_details": {"name": "Arial", "size": 12, "color": 0},
            "id": "text_1",
        }

        result = _render_element(self.mock_page, element, self.page_idx, self.page_overrides, self.config)

        self.assertIsInstance(result, dict)
        self.assertEqual(result["type"], "text")
        mock_render_text.assert_called_once()

    @patch("src.render.os.path.exists")
    def test_render_image_element(self, mock_exists):
        """Test rendering of image elements"""
        mock_exists.return_value = True
        self.mock_page.insert_image.return_value = None

        element = {
            "type": "image",
            "image_file": "./images/test.jpg",
            "bbox": [100, 100, 300, 300],
            "id": "image_1",
        }

        result = _render_element(self.mock_page, element, self.page_idx, self.page_overrides, self.config)

        self.assertIsInstance(result, dict)
        self.assertEqual(result["type"], "image")
        self.mock_page.insert_image.assert_called_once()

    @patch("src.render.os.path.exists")
    def test_render_image_element_missing_file(self, mock_exists):
        """Test rendering of image element with missing file"""
        mock_exists.return_value = False

        element = {
            "type": "image",
            "image_file": "./images/missing.jpg",
            "bbox": [100, 100, 300, 300],
            "id": "image_1",
        }

        result = _render_element(self.mock_page, element, self.page_idx, self.page_overrides, self.config)

        self.assertTrue(result.get("skipped", False))
        self.assertIn("error", result)
        self.mock_page.insert_image.assert_not_called()

    @patch("src.render._render_vector_element")
    def test_render_drawing_element(self, mock_render_vector):
        """Test rendering of drawing elements"""
        mock_render_vector.return_value = {"has_stroke": True, "has_fill": False}

        element = {
            "type": "drawing",
            "bbox": [100, 100, 200, 200],
            "drawing_commands": [
                {"cmd": "M", "pts": [100, 100]},
                {"cmd": "L", "pts": [200, 200]},
            ],
            "id": "drawing_1",
        }

        result = _render_element(self.mock_page, element, self.page_idx, self.page_overrides, self.config)

        self.assertIsInstance(result, dict)
        self.assertEqual(result["type"], "drawing")
        mock_render_vector.assert_called_once_with(self.mock_page, element)

    def test_render_unknown_element_type(self):
        """Test rendering of unknown element types"""
        element = {"type": "unknown", "id": "unknown_1"}

        result = _render_element(self.mock_page, element, self.page_idx, self.page_overrides, self.config)

        self.assertIn("error", result)
        self.assertIn("Unsupported element type", result["error"])

    def test_render_element_with_overrides(self):
        """Test rendering element with page overrides"""
        page_overrides = {"text_1": {"text": "Overridden Text", "font": "Times-Roman"}}

        element = {
            "type": "text",
            "text": "Original Text",
            "bbox": [100, 100, 300, 150],
            "font_details": {"name": "Arial", "size": 12, "color": 0},
            "id": "text_1",
        }

        with patch("src.render._render_text_with_fallback") as mock_render_text:
            with patch("src.render.ensure_font_registered") as mock_ensure_font:
                mock_ensure_font.return_value = "Times-Roman"
                mock_render_text.return_value = {
                    "fontname": "Times-Roman",
                    "fontsize": 12,
                }

                result = _render_element(self.mock_page, element, self.page_idx, page_overrides, self.config)

                self.assertIsInstance(result, dict)
                # Verify that overrides were applied
                call_args = mock_render_text.call_args[0]
                self.assertEqual(call_args[2], "Overridden Text")  # text parameter

    def test_render_element_exception_handling(self):
        """Test exception handling in element rendering"""
        element = {
            "type": "text",
            "text": "Test Text",
            "bbox": [100, 100, 300, 150],
            "font_details": {"name": "Arial", "size": 12, "color": 0},
            "id": "text_1",
        }

        with patch("src.render._render_text_with_fallback") as mock_render_text:
            mock_render_text.side_effect = RuntimeError("Rendering failed")

            result = _render_element(self.mock_page, element, self.page_idx, self.page_overrides, self.config)

            # Log exception in debug mode as required
            import logging

            logger = logging.getLogger(__name__)
            logger.debug(f"Element rendering handled exception: {result.get('error', 'No error info')}")

            self.assertIn("error", result)
            self.assertIn("Font fallback also failed", result["error"])
            self.assertIn("Rendering failed", result["error"])


if __name__ == "__main__":
    unittest.main()
