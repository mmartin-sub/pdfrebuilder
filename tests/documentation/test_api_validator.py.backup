"""
Tests for API reference validation system.
"""

import tempfile
from pathlib import Path

import pytest

from src.docs.api_validator import APIReference, APIReferenceValidator
from src.docs.validation import ValidationStatus


class TestAPIReferenceValidator:
    """Test cases for APIReferenceValidator."""

    def setup_method(self):
        """Set up test fixtures."""
        self.temp_dir = Path(tempfile.mkdtemp())
        self.validator = APIReferenceValidator(self.temp_dir)

        # Create basic project structure
        (self.temp_dir / "src").mkdir()
        (self.temp_dir / "docs").mkdir()

    def teardown_method(self):
        """Clean up test fixtures."""
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_scan_module_file(self):
        """Test scanning a Python module for API definitions."""
        # Create a test module
        test_module = self.temp_dir / "src" / "test_module.py"
        test_module.write_text(
            '''
"""Test module for API scanning."""

class TestClass:
    """A test class."""

    def test_method(self, param: str) -> bool:
        """A test method."""
        return True

    def undocumented_method(self):
        pass

def test_function(arg: int) -> str:
    """A test function."""
    return str(arg)

def undocumented_function():
    pass
'''
        )

        # Scan the module
        self.validator._scan_module_file(test_module)

        # Check that APIs were discovered
        assert len(self.validator._api_definitions) > 0

        # Check module definition
        assert "test_module" in self.validator._api_definitions
        module_def = self.validator._api_definitions["test_module"]
        assert module_def.definition_type == "module"
        assert "Test module for API scanning" in module_def.docstring

        # Check class definition
        assert "test_module.TestClass" in self.validator._api_definitions
        class_def = self.validator._api_definitions["test_module.TestClass"]
        assert class_def.definition_type == "class"
        assert "A test class" in class_def.docstring

        # Check method definition
        assert "test_module.TestClass.test_method" in self.validator._api_definitions
        method_def = self.validator._api_definitions["test_module.TestClass.test_method"]
        assert method_def.definition_type == "method"
        assert "A test method" in method_def.docstring

        # Check function definition
        assert "test_module.test_function" in self.validator._api_definitions
        func_def = self.validator._api_definitions["test_module.test_function"]
        assert func_def.definition_type == "function"
        assert "A test function" in func_def.docstring

    def test_extract_api_references(self):
        """Test extracting API references from documentation."""
        content = """
# Test Documentation

Here's how to use the API:

```python
from test_module import TestClass
obj = TestClass()
result = obj.test_method("hello")
```

You can also use `test_module.test_function()` directly.

Import the module with `import test_module`.
"""

        references = self.validator._extract_api_references(content, "test.md")

        # Should find several references
        assert len(references) > 0

        # Check for specific references
        ref_names = [ref.reference for ref in references]
        assert "test_module" in ref_names
        assert "test_module.TestClass" in ref_names

    def test_validate_valid_api_reference(self):
        """Test validating a valid API reference."""
        # Create test module and scan it
        test_module = self.temp_dir / "src" / "example.py"
        test_module.write_text(
            '''
"""Example module."""

def example_function():
    """An example function."""
    pass
'''
        )

        self.validator._scan_module_file(test_module)

        # Create a valid reference
        reference = APIReference(
            reference="example.example_function",
            reference_type="function_call",
            file_path="test.md",
            line_number=10,
            context="example_function()",
        )

        # Validate the reference
        result = self.validator._validate_single_api_reference(reference)

        # Should pass
        assert result.status == ValidationStatus.PASSED
        assert "Valid API reference" in result.message

    def test_validate_invalid_api_reference(self):
        """Test validating an invalid API reference."""
        # Create a reference to non-existent API
        reference = APIReference(
            reference="nonexistent.module.function",
            reference_type="function_call",
            file_path="test.md",
            line_number=10,
            context="nonexistent_function()",
        )

        # Validate the reference
        result = self.validator._validate_single_api_reference(reference)

        # Should fail
        assert result.status == ValidationStatus.FAILED
        assert "API reference not found" in result.message

    def test_validate_external_api_reference(self):
        """Test validating external API references."""
        # Create a reference to standard library
        reference = APIReference(
            reference="json.loads",
            reference_type="function_call",
            file_path="test.md",
            line_number=10,
            context="json.loads()",
        )

        # Validate the reference
        result = self.validator._validate_single_api_reference(reference)

        # Should pass as external
        assert result.status == ValidationStatus.PASSED
        assert "External API reference" in result.message

    def test_should_skip_reference(self):
        """Test reference skipping logic."""
        # Should skip built-in functions
        assert self.validator._should_skip_reference("print")
        assert self.validator._should_skip_reference("len")

        # Should skip short names
        assert self.validator._should_skip_reference("x")
        assert self.validator._should_skip_reference("i")

        # Should skip common variables
        assert self.validator._should_skip_reference("self")
        assert self.validator._should_skip_reference("data")

        # Should not skip qualified names
        assert not self.validator._should_skip_reference("module.function")
        assert not self.validator._should_skip_reference("MyClass")

    def test_get_function_signature(self):
        """Test extracting function signatures."""
        import ast

        # Test function with type annotations
        code = '''
def example_function(param1: str, param2: int = 10) -> bool:
    """Example function."""
    return True
'''

        tree = ast.parse(code)
        func_node = tree.body[0]

        signature = self.validator._get_function_signature(func_node)

        assert "example_function" in signature
        assert "param1: str" in signature
        assert "param2: int" in signature
        assert "-> bool" in signature

    def test_validate_file_api_references(self):
        """Test validating API references in a documentation file."""
        # Create test module
        test_module = self.temp_dir / "src" / "api_test.py"
        test_module.write_text(
            '''
"""API test module."""

def valid_function():
    """A valid function."""
    pass
'''
        )

        # Create documentation file
        doc_file = self.temp_dir / "docs" / "test_guide.md"
        doc_file.write_text(
            """
# Test Guide

Use `api_test.valid_function()` for testing.

You can also use `json.loads()` for JSON parsing.

Don't use `api_test.invalid_function()` as it doesn't exist.
"""
        )

        # Validate the file
        results = self.validator._validate_file_api_references(doc_file)

        # Should have results
        assert len(results) > 0

        # Check for different result types
        passed_results = [r for r in results if r.status == ValidationStatus.PASSED]
        failed_results = [r for r in results if r.status == ValidationStatus.FAILED]

        assert len(passed_results) > 0  # Should find valid references
        assert len(failed_results) > 0  # Should find invalid references

    def test_get_api_coverage_report(self):
        """Test generating API coverage report."""
        # Create test modules with varying documentation
        test_module1 = self.temp_dir / "src" / "documented.py"
        test_module1.write_text(
            '''
"""Well documented module."""

class DocumentedClass:
    """A well documented class."""

    def documented_method(self):
        """A documented method."""
        pass
'''
        )

        test_module2 = self.temp_dir / "src" / "undocumented.py"
        test_module2.write_text(
            """
class UndocumentedClass:
    def undocumented_method(self):
        pass

def undocumented_function():
    pass
"""
        )

        # Generate coverage report
        report = self.validator.get_api_coverage_report()

        # Check report structure
        assert "total_apis" in report
        assert "api_types" in report
        assert "undocumented_count" in report
        assert "documentation_coverage" in report

        # Should have found APIs
        assert report["total_apis"] > 0

        # Should have some undocumented APIs
        assert report["undocumented_count"] > 0

        # Coverage should be less than 100%
        assert report["documentation_coverage"] < 100

    def test_extract_references_from_code(self):
        """Test extracting references from code blocks."""
        code = """
from module import Class, function
obj = Class()
result = obj.method()
value = function(obj.attribute)
"""

        references = self.validator._extract_references_from_code(code, "test.md", 10)

        # Should find various types of references
        assert len(references) > 0

        # Check for specific reference types
        ref_types = [ref.reference_type for ref in references]
        assert "function_call" in ref_types or "method_call" in ref_types

    def test_find_partial_matches(self):
        """Test finding partial matches for API references."""
        # Add some API definitions
        self.validator._api_definitions = {
            "module.MyClass": None,
            "module.MyClass.method": None,
            "module.helper_function": None,
            "other.module.function": None,
        }

        # Test partial matching
        matches = self.validator._find_partial_matches("MyClass")
        assert len(matches) > 0
        assert any("MyClass" in match for match in matches)

        matches = self.validator._find_partial_matches("module.helper")
        assert len(matches) > 0
        assert any("helper_function" in match for match in matches)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
