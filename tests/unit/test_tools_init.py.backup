"""
Tests for tools module initialization and utility functions.
"""

import json
import os
import tempfile

from src.tools import detect_file_format, normalize_text_spacing, serialize_pdf_content_to_config


class TestToolsInit:
    """Test tools module utility functions"""

    def setup_method(self):
        """Set up test fixtures"""
        self.temp_dir = tempfile.mkdtemp()

    def test_serialize_pdf_content_to_config(self):
        """Test serializing PDF content to configuration file"""
        # Create dictionary content (not mock object)
        content_dict = {"version": "1.0", "engine": "fitz", "document_structure": []}

        config_path = os.path.join(self.temp_dir, "test_config.json")

        serialize_pdf_content_to_config(content_dict, config_path)

        # Verify file was created and contains expected content
        assert os.path.exists(config_path)

        with open(config_path) as f:
            saved_config = json.load(f)

        assert saved_config["version"] == "1.0"
        assert saved_config["engine"] == "fitz"
        assert "document_structure" in saved_config

    def test_serialize_pdf_content_to_config_with_complex_data(self):
        """Test serializing with complex data types"""
        # Create content with complex data types
        content_dict = {
            "version": "1.0",
            "complex_data": {"tuple_data": (1, 2, 3), "set_data": {1, 2, 3}},
        }

        config_path = os.path.join(self.temp_dir, "test_config.json")

        # This should not raise an exception due to custom serializer
        serialize_pdf_content_to_config(content_dict, config_path)

        # Verify file was created
        assert os.path.exists(config_path)

    def test_detect_file_format_pdf(self):
        """Test detecting PDF file format"""
        pdf_path = os.path.join(self.temp_dir, "test.pdf")
        with open(pdf_path, "wb") as f:
            f.write(b"%PDF-1.4\ntest content")

        result = detect_file_format(pdf_path)
        assert result == "pdf"

    def test_detect_file_format_psd(self):
        """Test detecting PSD file format"""
        psd_path = os.path.join(self.temp_dir, "test.psd")
        with open(psd_path, "wb") as f:
            f.write(b"8BPS\x00\x01test content")

        result = detect_file_format(psd_path)
        assert result == "psd"

    def test_detect_file_format_unknown(self):
        """Test detecting unknown file format"""
        unknown_path = os.path.join(self.temp_dir, "test.txt")
        with open(unknown_path, "w") as f:
            f.write("plain text content")

        result = detect_file_format(unknown_path)
        assert result == "unknown"

    def test_normalize_text_spacing_basic(self):
        """Test basic text spacing normalization"""
        # Test text with extra spaces (high space density)
        input_text = "H e l l o   W o r l d"
        result, changed = normalize_text_spacing(input_text)

        # Should remove spaces due to high space density
        assert changed is True
        assert result == "HelloWorld"

    def test_normalize_text_spacing_mixed_spacing(self):
        """Test text with mixed spacing patterns"""
        input_text = "T h i s  i s   a    t e s t"
        result, changed = normalize_text_spacing(input_text)

        # Should remove spaces due to high space density
        assert changed is True
        assert result == "Thisisatest"

    def test_normalize_text_spacing_no_change_needed(self):
        """Test text that doesn't need spacing normalization"""
        input_text = "Normal text here"
        result, changed = normalize_text_spacing(input_text)

        # Should not change normal text
        assert changed is False
        assert result == input_text

    def test_normalize_text_spacing_empty_string(self):
        """Test normalizing empty string"""
        result, changed = normalize_text_spacing("")
        assert result == ""
        assert changed is False

    def test_normalize_text_spacing_short_text(self):
        """Test normalizing short text (under threshold)"""
        result, changed = normalize_text_spacing("Hi")
        assert result == "Hi"
        assert changed is False

    def test_detect_file_format_by_extension(self):
        """Test detecting file format by extension when magic bytes fail"""
        # Create a PDF file without proper magic bytes
        pdf_path = os.path.join(self.temp_dir, "test.pdf")
        with open(pdf_path, "w") as f:
            f.write("not a real pdf but has .pdf extension")

        result = detect_file_format(pdf_path)
        assert result == "pdf"

    def test_detect_file_format_nonexistent_file(self):
        """Test detecting format of non-existent file"""
        non_existent_path = os.path.join(self.temp_dir, "nonexistent.pdf")

        result = detect_file_format(non_existent_path)
        assert result == "unknown"

    def test_serialize_pdf_content_with_document_structure(self):
        """Test serialization with document_structure key"""
        mock_document = {
            "version": "1.0",
            "document_structure": [
                {"type": "page", "page_number": 0},
                {"type": "page", "page_number": 1},
            ],
        }

        config_path = os.path.join(self.temp_dir, "test_config.json")

        # Capture print output
        import io
        import sys

        captured_output = io.StringIO()
        sys.stdout = captured_output

        serialize_pdf_content_to_config(mock_document, config_path)

        # Restore stdout
        sys.stdout = sys.__stdout__

        # Verify file was created
        assert os.path.exists(config_path)

        # Verify output contains expected message
        output = captured_output.getvalue()
        assert "Number of pages: 2" in output

    def teardown_method(self):
        """Clean up test fixtures"""
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)
