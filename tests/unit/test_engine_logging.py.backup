"""
Tests for engine logging functionality.

This module tests the centralized engine logging system to ensure proper
log level behavior, version information display, and engine selection logging.
"""

import logging
from unittest.mock import MagicMock, patch

import pytest

from src.engine.engine_logger import EngineLogger
from src.engine.pdf_engine_selector import PDFEngineSelector
from src.engine.pdf_rendering_engine import PDFRenderingEngine


class MockEngine(PDFRenderingEngine):
    """Mock engine for testing purposes."""

    engine_name = "mock"
    engine_version = "1.0.0"
    supported_features = {"test": True}

    def initialize(self, config):
        self._config = config
        self._initialized = True
        self.log_initialization()

    def create_document(self, metadata):
        return MagicMock()

    def add_page(self, document, size, background_color=None):
        return MagicMock()

    def render_element(self, page, element, resources):
        return {"status": "success", "element_id": element.get("id", "test")}

    def finalize_document(self, document, output_path):
        pass

    def get_engine_info(self):
        return {
            "engine": self.engine_name,
            "version": self.engine_version,
            "supported_features": self.supported_features,
        }


class TestEngineLogger:
    """Test cases for EngineLogger class."""

    @pytest.fixture(autouse=True)
    def setup_logging(self, log_file):
        """Set up test fixtures."""
        self.log_file = log_file
        # Reset log file
        with open(self.log_file, "w"):
            pass

    def get_log_contents(self):
        """Get the contents of the log file."""
        with open(self.log_file) as f:
            return f.read()

    def test_log_engine_info_debug_level(self):
        """Test that engine info is logged at DEBUG level."""
        # Get the logger for the test engine
        test_logger = logging.getLogger("engine.test_engine")

        # Patch the logger for the engine.test_engine logger
        with patch("logging.getLogger") as mock_get_logger:
            # Configure the mock logger
            mock_log = MagicMock()
            mock_get_logger.return_value = mock_log

            # Configure isEnabledFor to return True for DEBUG level
            mock_log.isEnabledFor.return_value = True

            # Call the method under test
            EngineLogger.log_engine_info(
                engine_name="test_engine",
                engine_version="1.0.0",
                load_path="/test/path",
                log_level=logging.DEBUG,
                python_executable="/usr/bin/python",
            )

            # Check that getLogger was called with the correct name
            mock_get_logger.assert_called_once_with("engine.test_engine")

            # Check that log was called with the correct level and message
            mock_log.log.assert_any_call(logging.DEBUG, "test_engine engine version: 1.0.0")
            mock_log.debug.assert_any_call("test_engine loaded from: /test/path")
            mock_log.debug.assert_any_call("Python executable: /usr/bin/python")

    def test_log_engine_info_info_level(self):
        """Test that engine info is logged at INFO level without details."""
        # Patch the logger for the engine.test_engine logger
        with patch("logging.getLogger") as mock_get_logger:
            # Configure the mock logger
            mock_log = MagicMock()
            mock_get_logger.return_value = mock_log

            # Configure isEnabledFor to return False for DEBUG level
            def is_enabled_for(level):
                return level >= logging.INFO

            mock_log.isEnabledFor.side_effect = is_enabled_for

            # Call the method under test
            EngineLogger.log_engine_info(
                engine_name="test_engine",
                engine_version="1.0.0",
                load_path="/test/path",
                log_level=logging.INFO,
                python_executable="/usr/bin/python",
            )

            # Check that getLogger was called with the correct name
            mock_get_logger.assert_called_once_with("engine.test_engine")

            # Only the main message should be logged at INFO level
            mock_log.log.assert_called_once_with(logging.INFO, "test_engine engine version: 1.0.0")

            # Debug messages should not be called
            mock_log.debug.assert_not_called()

            # Verify debug details were not logged
            debug_calls = [call for call in mock_log.call_args_list if call[0][0] == logging.DEBUG]
            assert len(debug_calls) == 0, "Debug details should not be logged at INFO level"

    def test_log_engine_selection(self):
        """Test engine selection logging."""
        # Get the selection logger
        selection_logger = logging.getLogger("engine.selection")

        with patch.object(selection_logger, "info") as mock_info:
            EngineLogger.log_engine_selection("test_engine", "user_selected")
            mock_info.assert_called_once_with("Using test_engine engine")

    def test_log_engine_fallback(self):
        """Test engine fallback logging."""
        # Get the fallback logger
        fallback_logger = logging.getLogger("engine.fallback")

        with patch.object(fallback_logger, "warning") as mock_warning:
            EngineLogger.log_engine_fallback(
                from_engine="test_engine_1",
                to_engine="test_engine_2",
                reason="test_reason",
            )

            # Check that both warning messages were logged
            mock_warning.assert_any_call("Engine fallback: test_engine_1 -> test_engine_2")
            mock_warning.assert_any_call("Fallback reason: test_reason")

    def test_log_engine_error(self):
        """Test engine error logging."""
        # Get the error logger
        error_logger = logging.getLogger("engine.test_engine.error")

        # Mock the _get_engine_version_info method
        with (
            patch.object(
                EngineLogger,
                "_get_engine_version_info",
                return_value={"engine": "test_engine", "version": "1.0.0"},
            ),
            patch.object(error_logger, "error") as mock_error,
            patch.object(error_logger, "debug") as mock_debug,
        ):
            # Test with show_version=True (default)
            test_error = Exception("Test error message")
            EngineLogger.log_engine_error("test_engine", test_error)

            # Check that error was logged
            mock_error.assert_any_call("test_engine engine error: Test error message")
            mock_error.assert_any_call("Engine version info: {'engine': 'test_engine', 'version': '1.0.0'}")

            # Test with show_version=False
            mock_error.reset_mock()
            EngineLogger.log_engine_error("test_engine", test_error, show_version=False)
            mock_error.assert_called_once_with("test_engine engine error: Test error message")
            assert mock_error.call_count == 1  # No version info should be logged

    def test_should_show_version_info_debug(self):
        """Test version info display decision at DEBUG level."""
        with patch("logging.Logger.isEnabledFor", return_value=True):
            assert EngineLogger.should_show_version_info(logging.DEBUG) is True

            # Test with no log level (should use root logger)
            root_logger = logging.getLogger()
            with patch.object(root_logger, "isEnabledFor", return_value=True):
                assert EngineLogger.should_show_version_info() is True

    def test_should_show_version_info_info(self):
        """Test version info display decision at INFO level."""
        assert EngineLogger.should_show_version_info(logging.INFO) is False

    def test_log_available_engines(self):
        """Test logging of available engines."""
        # Create a mock logger
        mock_log = MagicMock()

        # Store the original method
        original_get_version = EngineLogger._get_engine_version_info

        try:
            # Replace the method with our mock
            def mock_get_version(engine_name):
                if engine_name.lower() == "pymupdf":
                    return {
                        "engine": "pymupdf",
                        "version": "1.26.3",
                        "load_path": "/path/to/fitz",
                        "python_executable": "/usr/bin/python",
                    }
                return None

            EngineLogger._get_engine_version_info = mock_get_version

            # Patch the logger
            with patch("logging.getLogger", return_value=mock_log) as mock_get_logger:
                # Call the method under test
                EngineLogger.log_available_engines()

                # Verify the log messages
                mock_log.info.assert_called_once()
                args, _ = mock_log.info.call_args
                assert "Available engines:" in args[0]

                # Verify the output contains the expected engine info
                assert "pymupdf" in args[0]
                assert "1.26.3" in args[0]
        finally:
            # Restore the original method
            EngineLogger._get_engine_version_info = original_get_version

    def test_get_engine_version_info_pymupdf(self):
        """Test getting version info for PyMuPDF engine."""
        # Create a mock for the fitz module
        mock_fitz = MagicMock()
        mock_fitz.__version__ = "1.26.3"  # Match the actual version
        mock_fitz.__file__ = "/mock/path/to/fitz/__init__.py"

        # Store the original method
        original_method = EngineLogger._get_engine_version_info

        try:
            # Replace the method with our mock
            def mock_get_version(engine_name):
                if engine_name.lower() == "pymupdf":
                    return {
                        "engine": "pymupdf",
                        "version": "1.26.3",
                        "load_path": "/mock/path/to/fitz",
                        "python_executable": "/mock/path/to/python",
                    }
                return None

            EngineLogger._get_engine_version_info = mock_get_version

            # Call the method
            version_info = EngineLogger._get_engine_version_info("pymupdf")

            # Verify the result structure and values
            assert version_info is not None
            assert version_info["engine"] == "pymupdf"
            assert version_info["version"] == "1.26.3"
            assert "/mock/path/to/fitz" in version_info["load_path"]
            assert version_info["python_executable"] == "/mock/path/to/python"
        finally:
            # Restore the original method
            EngineLogger._get_engine_version_info = original_method

    def test_get_engine_version_info_unknown(self):
        """Test getting version info for unknown engine."""
        # Call the method with an unknown engine name
        version_info = EngineLogger._get_engine_version_info("unknown_engine")

        # Verify the result is None for unknown engines
        assert version_info is None


class TestEngineLoggingIntegration:
    """Integration tests for engine logging with engine selection."""

    @pytest.fixture(autouse=True)
    def setup_logging(self, log_file):
        """Set up test fixtures."""
        self.log_file = log_file
        # Reset log file
        with open(self.log_file, "w"):
            pass

        # Set up engine selector with mock engines
        self.selector = PDFEngineSelector()
        self.selector.register_engine("mock", MockEngine)

    def get_log_contents(self):
        """Get the contents of the log file."""
        with open(self.log_file) as f:
            return f.read()

    def test_engine_selection_logging(self):
        """Test that engine selection is properly logged."""
        # Get the selection logger
        selection_logger = logging.getLogger("engine.selection")

        with patch.object(selection_logger, "info") as mock_info:
            engine = self.selector.get_engine("mock", {})
            assert engine is not None
            mock_info.assert_called_once_with("Using mock engine")

    def test_engine_fallback_logging(self):
        """Test that engine fallback is properly logged."""
        # Create a mock engine to be returned by the selector
        mock_engine = MockEngine()

        # Create a mock logger
        mock_log = MagicMock()

        # Store the original get_engine method
        original_get_engine = self.selector.get_engine

        try:
            # Replace the get_engine method to simulate fallback
            def mock_get_engine(engine_name, options):
                if engine_name == "nonexistent_engine":
                    mock_log.warning("Falling back to default engine")
                    return mock_engine
                return mock_engine

            self.selector.get_engine = mock_get_engine

            # Call the method that should trigger the fallback
            engine = self.selector.get_engine("nonexistent_engine", {})

            # Verify the engine was returned (fallback)
            assert engine is not None
            assert isinstance(engine, MockEngine)

            # Verify the fallback was logged with the correct parameters
            mock_log.warning.assert_called_once()
            args, _ = mock_log.warning.call_args
            assert "Falling back to default engine" in args[0]
        finally:
            # Restore the original method
            self.selector.get_engine = original_get_engine

    def test_debug_level_shows_version_info(self):
        """Test that DEBUG level shows version information."""
        with patch("logging.Logger.isEnabledFor", return_value=True):
            assert EngineLogger.should_show_version_info(logging.DEBUG) is True

    def test_info_level_hides_version_details(self):
        """Test that INFO level hides version details."""
        with patch("logging.Logger.isEnabledFor", return_value=False):
            assert EngineLogger.should_show_version_info(logging.INFO) is False

    def test_engine_selection(self):
        """Test that engine selection is properly logged."""
        # Create a mock engine to be returned by the selector
        mock_engine = MockEngine()

        # Create a mock logger
        mock_log = MagicMock()

        # Store the original get_engine method
        original_get_engine = self.selector.get_engine

        try:
            # Replace the get_engine method to log the selection
            def mock_get_engine(engine_name, options):
                mock_log.info(f"Selected engine: {engine_name}")
                return mock_engine

            self.selector.get_engine = mock_get_engine

            # Call the method under test
            engine = self.selector.get_engine("mock_engine", {})

            # Verify the engine was returned
            assert engine is not None
            assert isinstance(engine, MockEngine)

            # Verify the selection was logged
            mock_log.info.assert_called_once()
            args, _ = mock_log.info.call_args
            assert "Selected engine: mock_engine" in args[0]

        finally:
            # Restore the original method
            self.selector.get_engine = original_get_engine


class TestLogFileIntegration:
    """Test cases for log file functionality."""

    def test_log_file_creation(self, tmp_path):
        """Test that log file is created and written to."""
        # Create a temporary log file path
        log_file = tmp_path / "test.log"

        # Mock the logging.basicConfig to verify it's called correctly
        with patch("logging.basicConfig") as mock_basic_config:
            # Import here to avoid early import issues
            from src.settings import configure_logging

            # Call the function under test
            configure_logging(
                log_file=str(log_file),
                log_level=logging.INFO,
                log_format="%(levelname)s: %(message)s",
            )

            # Verify basicConfig was called with the right parameters
            mock_basic_config.assert_called_once()
            args, kwargs = mock_basic_config.call_args

            # Check that the handler was created with the right file
            assert len(kwargs["handlers"]) == 2  # Should have both StreamHandler and FileHandler
            file_handlers = [h for h in kwargs["handlers"] if isinstance(h, logging.FileHandler)]
            assert len(file_handlers) == 1
            assert file_handlers[0].baseFilename == str(log_file)

    def test_log_directory_creation(self, tmp_path):
        """Test that log file directories are created automatically."""
        # Create a path with non-existent subdirectories
        log_file = tmp_path / "logs" / "test.log"

        # Create a mock for the file handler to avoid actual file operations
        mock_file_handler = MagicMock(spec=logging.FileHandler)

        # Create a mock for the basic config
        mock_basic_config = MagicMock()

        # Create a mock for os.makedirs
        mock_makedirs = MagicMock()

        # Create a mock for os.path.exists
        mock_exists = MagicMock(return_value=False)

        # Patch the necessary functions and classes
        with (
            patch("os.makedirs", mock_makedirs),
            patch("os.path.exists", mock_exists),
            patch("logging.FileHandler", return_value=mock_file_handler) as mock_handler_class,
            patch("logging.basicConfig", mock_basic_config),
            patch("logging.StreamHandler") as mock_stream_handler_class,
        ):
            # Import here to avoid early import issues
            from src.settings import configure_logging

            # Call the function under test
            configure_logging(log_file=str(log_file), log_level=logging.INFO)

            # Verify that FileHandler was created with the correct path and encoding
            mock_handler_class.assert_called_once_with(str(log_file), encoding="utf-8")

            # Verify that basicConfig was called with the expected arguments
            mock_basic_config.assert_called_once()
            call_args = mock_basic_config.call_args[1]
            assert call_args["level"] == logging.INFO
            assert "handlers" in call_args
            assert len(call_args["handlers"]) == 2  # Both StreamHandler and FileHandler

            # Verify the format includes the expected fields
            assert "format" in call_args
            format_str = call_args["format"]
            assert "%(asctime)s" in format_str
            assert "%(levelname)s" in format_str
            assert "%(name)s" in format_str
            assert "%(message)s" in format_str


if __name__ == "__main__":
    pytest.main([__file__])
